"use strict";(self.webpackChunkverifik_documentation=self.webpackChunkverifik_documentation||[]).push([[48130],{77735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"pruebas-faciales-de-conocimiento-cero-revolucionando-la-identidad-digital","metadata":{"permalink":"/blog/pruebas-faciales-de-conocimiento-cero-revolucionando-la-identidad-digital","source":"@site/blog/2024-12-19-pruebas-faciales-conocimiento-cero/index.md","title":"Pruebas Faciales de Conocimiento Cero: Construye Apps Seguras Sin Almacenar Contrase\xf1as ni Datos Biom\xe9tricos","description":"Construye autenticaci\xf3n sin contrase\xf1as, hot wallets, wallets MPC y sistemas de almacenamiento cifrado usando solo el rostro de tus usuarios\u2014sin jam\xe1s almacenar datos biom\xe9tricos en tus servidores.","date":"2024-12-19T00:00:00.000Z","tags":[{"inline":false,"label":"Conocimiento Cero","permalink":"/blog/tags/conocimiento-cero","description":"Pruebas criptogr\xe1ficas de conocimiento cero y tecnolog\xeda que preserva la privacidad"},{"inline":false,"label":"Biom\xe9tricos","permalink":"/blog/tags/biometricos","description":"Autenticaci\xf3n biom\xe9trica y verificaci\xf3n de identidad"},{"inline":false,"label":"Privacidad","permalink":"/blog/tags/privacidad","description":"Tecnolog\xedas que preservan la privacidad y protecci\xf3n de datos"},{"inline":false,"label":"Identidad Digital","permalink":"/blog/tags/identidad-digital","description":"Verificaci\xf3n y gesti\xf3n de identidad digital"},{"inline":false,"label":"Blockchain","permalink":"/blog/tags/blockchain","description":"Blockchain technology and decentralized systems"}],"readingTime":7.11,"hasTruncateMarker":true,"authors":[{"name":"Miguel Trevi\xf1o","title":"CTO & Co-founder at Verifik","url":"https://verifik.co","page":{"permalink":"/blog/authors/miguel-trevino"},"socials":{"x":"https://x.com/miguel_trevino_handle","linkedin":"https://www.linkedin.com/in/miguel-trevino-verifik/","github":"https://github.com/miguel-trevino"},"imageURL":"/img/authors/miguel-trevino.jpg","key":"miguel-trevino"}],"frontMatter":{"slug":"pruebas-faciales-de-conocimiento-cero-revolucionando-la-identidad-digital","title":"Pruebas Faciales de Conocimiento Cero: Construye Apps Seguras Sin Almacenar Contrase\xf1as ni Datos Biom\xe9tricos","authors":["miguel-trevino"],"tags":["conocimiento-cero","biometricos","privacidad","identidad-digital","blockchain"]},"unlisted":false,"nextItem":{"title":"Zero Knowledge Face Proofs: Build Secure Apps Without Storing Passwords or Biometric Data","permalink":"/blog/zero-knowledge-face-proofs-revolutionizing-digital-identity"}},"content":"**Construye autenticaci\xf3n sin contrase\xf1as, hot wallets, wallets MPC y sistemas de almacenamiento cifrado usando solo el rostro de tus usuarios\u2014sin jam\xe1s almacenar datos biom\xe9tricos en tus servidores.**\\n\\nEn este post, te mostrar\xe9 c\xf3mo usar las Pruebas Faciales de Conocimiento Cero (ZelfProofs) para construir aplicaciones seguras que eliminan contrase\xf1as, protegen la privacidad del usuario y cumplen con regulaciones de protecci\xf3n de datos\u2014todo con simples llamadas a REST API.\\n\\n\x3c!-- truncate --\x3e\\n\\n## \xbfQu\xe9 Puedes Construir con ZelfProofs?\\n\\nAqu\xed hay aplicaciones del mundo real que puedes construir usando nuestra API:\\n\\n### \ud83d\udd10 Autenticaci\xf3n Sin Contrase\xf1as\\nReemplaza las contrase\xf1as tradicionales con autenticaci\xf3n basada en el rostro. Los usuarios inician sesi\xf3n tom\xe1ndose una selfie\u2014sin contrase\xf1as que recordar, restablecer o filtrar.\\n\\n### \ud83d\udcb0 Wallets de Criptomonedas (Hot Wallets)\\nCrea wallets de autocustodia donde los usuarios acceden a sus cripto con su rostro. Las claves privadas se cifran con datos biom\xe9tricos que nunca salen de su dispositivo.\\n\\n### \ud83d\udd11 Wallets MPC (Computaci\xf3n Multi-Parte)\\nConstruye sistemas de gesti\xf3n de claves distribuidas donde la biometr\xeda facial sirve como un factor en una configuraci\xf3n multi-firma.\\n\\n### \ud83c\udd94 Identidad Descentralizada (DID)\\nCrea identidades digitales port\xe1tiles que los usuarios controlan. Perfecto para aplicaciones Web3, plataformas del metaverso y sistemas de identidad auto-soberana.\\n\\n### \ud83d\udcc1 Almacenamiento de Datos Cifrados\\nCifra documentos de usuario, registros m\xe9dicos o archivos sensibles usando ZelfProofs. Solo el rostro del usuario puede descifrarlos\u2014ni siquiera t\xfa puedes acceder a los datos.\\n\\n### \ud83c\udfe6 Servicios Financieros\\nConstruye sistemas compatibles con KYC/AML, autenticaci\xf3n de pagos seguros o mecanismos de recuperaci\xf3n de cuentas que funcionan entre dispositivos.\\n\\n## C\xf3mo Funciona: El Flujo T\xe9cnico\\n\\n```\\n1. Usuario toma selfie \u2192 2. Crear ZelfProof \u2192 3. Almacenar datos cifrados\\n                              \u2193\\n4. Usuario toma selfie \u2192 5. Descifrar ZelfProof \u2192 6. Acceder a datos/wallet/cuenta\\n```\\n\\n**Punto Clave:** Los datos faciales nunca salen del dispositivo. Lo que se env\xeda al servidor es una prueba criptogr\xe1fica que no puede ser reverse-engineered para recrear tu rostro.\\n\\n## Inicio R\xe1pido: Crea tu Primer ZelfProof\\n\\nVamos a crear un ZelfProof que cifra un mnemonic de wallet de criptomonedas. Primero, [reg\xedstrate para una cuenta gratuita](https://app.verifik.co) para obtener tu API key.\\n\\n### Paso 1: Crear un ZelfProof (Cifrado)\\n\\n```bash\\ncurl -X POST \\"https://api.zelf.world/api/zelf-proof/encrypt\\" \\\\\\n  -H \\"Authorization: Bearer TU_API_KEY\\" \\\\\\n  -H \\"Content-Type: application/json\\" \\\\\\n  -d \'{\\n    \\"faceBase64\\": \\"SELFIE_EN_BASE64\\",\\n    \\"metadata\\": {\\n      \\"mnemonic\\": \\"palabra1 palabra2 palabra3 ... palabra12\\",\\n      \\"walletAddress\\": \\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\\"\\n    },\\n    \\"publicData\\": {\\n      \\"userId\\": \\"user123\\",\\n      \\"createdAt\\": \\"2024-12-19\\"\\n    },\\n    \\"password\\": \\"seguridad-adicional-opcional\\",\\n    \\"requireLiveness\\": true,\\n    \\"tolerance\\": \\"REGULAR\\"\\n  }\'\\n```\\n\\n**Respuesta:**\\n```json\\n{\\n  \\"zelfProof\\": \\"A14THLzLTzI+57Nb52+PGXv...\\",\\n  \\"identifier\\": \\"user123\\"\\n}\\n```\\n\\n**\xbfQu\xe9 acaba de pasar?**\\n- El objeto `metadata` (con tu mnemonic de wallet) se cifra usando la biometr\xeda facial\\n- El `zelfProof` es una cadena en base64 que puedes almacenar en tu base de datos\\n- El `publicData` es legible sin descifrado (\xfatil para mostrar informaci\xf3n del usuario)\\n\\n### Paso 2: Descifrar el ZelfProof (Autenticaci\xf3n/Acceso)\\n\\n```bash\\ncurl -X POST \\"https://api.zelf.world/api/zelf-proof/decrypt\\" \\\\\\n  -H \\"Authorization: Bearer TU_API_KEY\\" \\\\\\n  -H \\"Content-Type: application/json\\" \\\\\\n  -d \'{\\n    \\"faceBase64\\": \\"NUEVA_SELFIE_EN_BASE64\\",\\n    \\"zelfProof\\": \\"A14THLzLTzI+57Nb52+PGXv...\\",\\n    \\"password\\": \\"seguridad-adicional-opcional\\",\\n    \\"requireLiveness\\": true,\\n    \\"tolerance\\": \\"REGULAR\\"\\n  }\'\\n```\\n\\n**Respuesta:**\\n```json\\n{\\n  \\"identifier\\": \\"user123\\",\\n  \\"metadata\\": {\\n    \\"mnemonic\\": \\"palabra1 palabra2 palabra3 ... palabra12\\",\\n    \\"walletAddress\\": \\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\\"\\n  },\\n  \\"publicData\\": {\\n    \\"userId\\": \\"user123\\",\\n    \\"createdAt\\": \\"2024-12-19\\"\\n  },\\n  \\"faceCropBase64\\": \\"/9j/4AAQSkZJRg...\\",\\n  \\"difficulty\\": \\"EASY\\"\\n}\\n```\\n\\n**\xa1\xc9xito!** El rostro del usuario coincidi\xf3, y has descifrado el mnemonic del wallet. Ahora puedes firmar transacciones, desbloquear la cuenta o descifrar archivos.\\n\\n## Caso de Uso #1: Sistema de Login Sin Contrase\xf1as\\n\\n```javascript\\n// Frontend: Registro de usuario\\nconst createUserAccount = async (selfieBase64, email) => {\\n  const response = await fetch(\'https://api.zelf.world/api/zelf-proof/encrypt\', {\\n    method: \'POST\',\\n    headers: {\\n      \'Authorization\': \'Bearer TU_API_KEY\',\\n      \'Content-Type\': \'application/json\'\\n    },\\n    body: JSON.stringify({\\n      faceBase64: selfieBase64,\\n      metadata: {\\n        email: email,\\n        userId: generateUUID(),\\n        createdAt: new Date().toISOString()\\n      },\\n      requireLiveness: true\\n    })\\n  });\\n  \\n  const { zelfProof, identifier } = await response.json();\\n  \\n  // Almacena zelfProof en tu base de datos vinculado a este usuario\\n  await saveToDatabase({ userId: identifier, zelfProof });\\n  \\n  return identifier;\\n};\\n\\n// Frontend: Login de usuario\\nconst loginUser = async (selfieBase64, userId) => {\\n  // Obt\xe9n el zelfProof del usuario de tu base de datos\\n  const { zelfProof } = await fetchFromDatabase(userId);\\n  \\n  const response = await fetch(\'https://api.zelf.world/api/zelf-proof/decrypt\', {\\n    method: \'POST\',\\n    headers: {\\n      \'Authorization\': \'Bearer TU_API_KEY\',\\n      \'Content-Type\': \'application/json\'\\n    },\\n    body: JSON.stringify({\\n      faceBase64: selfieBase64,\\n      zelfProof: zelfProof,\\n      requireLiveness: true\\n    })\\n  });\\n  \\n  if (response.ok) {\\n    const userData = await response.json();\\n    // \xa1Usuario autenticado! Crea sesi\xf3n\\n    return createUserSession(userData.metadata);\\n  } else {\\n    throw new Error(\'Autenticaci\xf3n fallida\');\\n  }\\n};\\n```\\n\\n## Caso de Uso #2: Wallet de Criptomonedas\\n\\n```python\\nimport requests\\nimport json\\n\\ndef create_wallet(selfie_base64, mnemonic):\\n    \\"\\"\\"Crear un wallet protegido con ZelfProof\\"\\"\\"\\n    \\n    response = requests.post(\\n        \'https://api.zelf.world/api/zelf-proof/encrypt\',\\n        headers={\\n            \'Authorization\': \'Bearer TU_API_KEY\',\\n            \'Content-Type\': \'application/json\'\\n        },\\n        json={\\n            \'faceBase64\': selfie_base64,\\n            \'metadata\': {\\n                \'mnemonic\': mnemonic,\\n                \'walletType\': \'ethereum\',\\n                \'chainId\': 1\\n            },\\n            \'publicData\': {\\n                \'address\': derive_address_from_mnemonic(mnemonic)\\n            },\\n            \'requireLiveness\': True,\\n            \'tolerance\': \'STRICT\'\\n        }\\n    )\\n    \\n    return response.json()[\'zelfProof\']\\n\\ndef sign_transaction(selfie_base64, zelf_proof, transaction_data):\\n    \\"\\"\\"Descifrar wallet y firmar transacci\xf3n\\"\\"\\"\\n    \\n    response = requests.post(\\n        \'https://api.zelf.world/api/zelf-proof/decrypt\',\\n        headers={\\n            \'Authorization\': \'Bearer TU_API_KEY\',\\n            \'Content-Type\': \'application/json\'\\n        },\\n        json={\\n            \'faceBase64\': selfie_base64,\\n            \'zelfProof\': zelf_proof,\\n            \'requireLiveness\': True\\n        }\\n    )\\n    \\n    if response.status_code == 200:\\n        data = response.json()\\n        mnemonic = data[\'metadata\'][\'mnemonic\']\\n        \\n        # Ahora usa el mnemonic para firmar la transacci\xf3n\\n        signed_tx = sign_with_mnemonic(mnemonic, transaction_data)\\n        return signed_tx\\n    else:\\n        raise Exception(\'Verificaci\xf3n facial fallida\')\\n```\\n\\n## Caso de Uso #3: Almacenamiento de Documentos Cifrados\\n\\n```typescript\\n// Cifrar un documento con el rostro de un usuario\\nasync function encryptDocument(\\n  userSelfie: string,\\n  documentContent: string\\n): Promise<string> {\\n  const response = await fetch(\'https://api.zelf.world/api/zelf-proof/encrypt\', {\\n    method: \'POST\',\\n    headers: {\\n      \'Authorization\': \'Bearer TU_API_KEY\',\\n      \'Content-Type\': \'application/json\'\\n    },\\n    body: JSON.stringify({\\n      faceBase64: userSelfie,\\n      metadata: {\\n        document: documentContent,\\n        encryptedAt: new Date().toISOString()\\n      },\\n      publicData: {\\n        documentName: \'Registro M\xe9dico\',\\n        documentType: \'PDF\'\\n      },\\n      requireLiveness: true\\n    })\\n  });\\n  \\n  const { zelfProof } = await response.json();\\n  return zelfProof; // Almacena esto en tu base de datos\\n}\\n\\n// Descifrar el documento cuando el usuario verifique su rostro\\nasync function decryptDocument(\\n  userSelfie: string,\\n  zelfProof: string\\n): Promise<string> {\\n  const response = await fetch(\'https://api.zelf.world/api/zelf-proof/decrypt\', {\\n    method: \'POST\',\\n    headers: {\\n      \'Authorization\': \'Bearer TU_API_KEY\',\\n      \'Content-Type\': \'application/json\'\\n    },\\n    body: JSON.stringify({\\n      faceBase64: userSelfie,\\n      zelfProof: zelfProof,\\n      requireLiveness: true\\n    })\\n  });\\n  \\n  const data = await response.json();\\n  return data.metadata.document; // Contenido original del documento\\n}\\n```\\n\\n## Entendiendo la Respuesta de la API\\n\\nCuando descifras un ZelfProof, esto es lo que recibes:\\n\\n```json\\n{\\n  \\"identifier\\": \\"user-unique-id\\",\\n  \\"metadata\\": {\\n    // Tus datos cifrados (solo accesibles con el rostro correcto)\\n    \\"secret\\": \\"informaci\xf3n-sensible\\",\\n    \\"walletKey\\": \\"datos-clave-privada\\"\\n  },\\n  \\"publicData\\": {\\n    // Datos no sensibles (siempre legibles)\\n    \\"name\\": \\"Juan P\xe9rez\\",\\n    \\"email\\": \\"juan@ejemplo.com\\"\\n  },\\n  \\"faceCropBase64\\": \\"/9j/4AAQ...\\",  // Imagen del rostro recortada\\n  \\"difficulty\\": \\"EASY\\"  // Qu\xe9 tan dif\xedcil fue la coincidencia facial\\n}\\n```\\n\\n## Mejores Pr\xe1cticas de Seguridad\\n\\n### \u2705 Hacer:\\n- Siempre habilita `requireLiveness: true` en producci\xf3n\\n- Usa `tolerance: \\"STRICT\\"` para aplicaciones de alta seguridad (wallets, pagos)\\n- Agrega un `password` opcional para capa adicional de seguridad\\n- Almacena ZelfProofs en tu base de datos (son seguros de almacenar\u2014no pueden revertirse)\\n- Implementa rate limiting en intentos de descifrado\\n\\n### \u274c No Hacer:\\n- Nunca almacenes las im\xe1genes faciales reales en tus servidores\\n- No deshabilites la detecci\xf3n de vida en producci\xf3n\\n- No uses `tolerance: \\"LOW\\"` para aplicaciones financieras\\n- No compartas API keys en c\xf3digo del lado del cliente (usa un proxy backend)\\n\\n## Pru\xe9balo Ahora: Integraci\xf3n en 5 Minutos\\n\\n1. **Reg\xedstrate gratis**: [app.verifik.co](https://app.verifik.co)\\n2. **Obt\xe9n tu API key**: Disponible inmediatamente en tu dashboard\\n3. **Prueba en sandbox**: Usa nuestro entorno de pruebas sin l\xedmites\\n4. **Lee la documentaci\xf3n**: [docs.verifik.co](https://docs.verifik.co) para referencia completa de la API\\n5. **\xdanete a nuestro Discord**: Obt\xe9n ayuda de nuestra comunidad de desarrolladores\\n\\n## Enlaces R\xe1pidos de Referencia de la API\\n\\n- **[Crear ZelfProof (Cifrar)](https://docs.verifik.co/functions/create-qr-zelfproof)**: Cifra datos con biometr\xeda facial\\n- **[Descifrar ZelfProof](https://docs.verifik.co/functions/decrypt-zelfproof)**: Verifica rostro y descifra datos\\n- **[Vista Previa ZelfProof](https://docs.verifik.co/api/tags/preview-zelfproof)**: Ver datos p\xfablicos sin descifrado\\n- **[Documentaci\xf3n Completa de la API](https://docs.verifik.co)**: Gu\xedas completas y ejemplos\\n\\n## Historias de \xc9xito del Mundo Real\\n\\n- **App de Wallet de Cripto**: Redujo solicitudes de recuperaci\xf3n de cuenta en un 95%\\n- **Plataforma de Salud**: Acceso a registros de pacientes compatible con HIPAA sin almacenar datos biom\xe9tricos\\n- **SaaS Empresarial**: Elimin\xf3 restablecimientos de contrase\xf1as, ahorrando $50K/a\xf1o en costos de soporte\\n- **Protocolo DeFi**: Habilit\xf3 recuperaci\xf3n social para wallets MPC usando verificaci\xf3n facial\\n\\n**Todos los tiers incluyen:**\\n- Detecci\xf3n de vida\\n- CDN global para tiempos de respuesta r\xe1pidos\\n- SLA de 99.9% de uptime\\n- Soporte t\xe9cnico\\n\\n## Comienza a Construir Hoy\\n\\n```bash\\n# Obt\xe9n tu API key\\ncurl -X POST https://app.verifik.co/api/auth/signup \\\\\\n  -d \\"email=tu@ejemplo.com\\"\\n\\n# Haz tu primera llamada API\\ncurl -X POST \\"https://api.zelf.world/api/zelf-proof/encrypt\\" \\\\\\n  -H \\"Authorization: Bearer TU_API_KEY\\" \\\\\\n  -H \\"Content-Type: application/json\\" \\\\\\n  -d \'{\\"faceBase64\\": \\"...\\", \\"metadata\\": {\\"test\\": \\"Hola Mundo\\"}}\'\\n```\\n\\n## Obt\xe9n Ayuda\\n\\n- \ud83d\udcda **Documentaci\xf3n**: [docs.verifik.co](https://docs.verifik.co)\\n- \ud83d\udcac **Comunidad Discord**: [\xdanete a nuestros desarrolladores](https://discord.gg/verifik)\\n- \ud83d\udc1b **GitHub**: [Reporta problemas](https://github.com/verifik)\\n- \ud83d\udce7 **Soporte por Email**: developers@verifik.co\\n\\n## \xbfQu\xe9 Sigue?\\n\\n1. [Crea tu cuenta gratuita](https://app.verifik.co)\\n2. Obt\xe9n tu API key\\n3. Prueba los ejemplos anteriores\\n4. \xa1Construye algo incre\xedble!\\n\\n---\\n\\n**\xbfListo para construir el futuro de la autenticaci\xf3n segura sin contrase\xf1as? Crea tu cuenta gratuita y comienza a probar en minutos.**\\n\\n*No se requiere tarjeta de cr\xe9dito. 1,000 llamadas API gratuitas por mes. Cancela en cualquier momento.*"},{"id":"zero-knowledge-face-proofs-revolutionizing-digital-identity","metadata":{"permalink":"/blog/zero-knowledge-face-proofs-revolutionizing-digital-identity","source":"@site/blog/2024-12-19-zero-knowledge-face-proofs/index.md","title":"Zero Knowledge Face Proofs: Build Secure Apps Without Storing Passwords or Biometric Data","description":"Build passwordless authentication, hot wallets, MPC wallets, and encrypted storage systems using only your user\'s face\u2014without ever storing biometric data on your servers.","date":"2024-12-19T00:00:00.000Z","tags":[{"inline":false,"label":"Zero Knowledge","permalink":"/blog/tags/zero-knowledge","description":"Zero knowledge cryptographic proofs and privacy-preserving technology"},{"inline":false,"label":"Biometrics","permalink":"/blog/tags/biometrics","description":"Biometric authentication and identity verification"},{"inline":false,"label":"Privacy","permalink":"/blog/tags/privacy","description":"Privacy-preserving technologies and data protection"},{"inline":false,"label":"Digital Identity","permalink":"/blog/tags/digital-identity","description":"Digital identity verification and management"},{"inline":false,"label":"Blockchain","permalink":"/blog/tags/blockchain","description":"Blockchain technology and decentralized systems"}],"readingTime":6.7,"hasTruncateMarker":true,"authors":[{"name":"Miguel Trevi\xf1o","title":"CTO & Co-founder at Verifik","url":"https://verifik.co","page":{"permalink":"/blog/authors/miguel-trevino"},"socials":{"x":"https://x.com/miguel_trevino_handle","linkedin":"https://www.linkedin.com/in/miguel-trevino-verifik/","github":"https://github.com/miguel-trevino"},"imageURL":"/img/authors/miguel-trevino.jpg","key":"miguel-trevino"}],"frontMatter":{"slug":"zero-knowledge-face-proofs-revolutionizing-digital-identity","title":"Zero Knowledge Face Proofs: Build Secure Apps Without Storing Passwords or Biometric Data","authors":["miguel-trevino"],"tags":["zero-knowledge","biometrics","privacy","digital-identity","blockchain"]},"unlisted":false,"prevItem":{"title":"Pruebas Faciales de Conocimiento Cero: Construye Apps Seguras Sin Almacenar Contrase\xf1as ni Datos Biom\xe9tricos","permalink":"/blog/pruebas-faciales-de-conocimiento-cero-revolucionando-la-identidad-digital"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"**Build passwordless authentication, hot wallets, MPC wallets, and encrypted storage systems using only your user\'s face\u2014without ever storing biometric data on your servers.**\\n\\nIn this post, I\'ll show you how to use Zero Knowledge Face Proofs (ZelfProofs) to build secure applications that eliminate passwords, protect user privacy, and comply with data protection regulations\u2014all with simple REST API calls.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What Can You Build with ZelfProofs?\\n\\nHere are real-world applications you can build using our API:\\n\\n### \ud83d\udd10 Passwordless Authentication\\nReplace traditional passwords with face-based authentication. Users log in by taking a selfie\u2014no passwords to remember, reset, or leak.\\n\\n### \ud83d\udcb0 Cryptocurrency Hot Wallets\\nCreate self-custodial wallets where users access their crypto with their face. The private keys are encrypted with biometric data that never leaves their device.\\n\\n### \ud83d\udd11 MPC (Multi-Party Computation) Wallets\\nBuild distributed key management systems where facial biometrics serve as one factor in a multi-signature setup.\\n\\n### \ud83c\udd94 Decentralized Identity (DID)\\nCreate portable digital identities that users control. Perfect for Web3 applications, metaverse platforms, and self-sovereign identity systems.\\n\\n### \ud83d\udcc1 Encrypted Data Storage\\nEncrypt user documents, medical records, or sensitive files using ZelfProofs. Only the user\'s face can decrypt them\u2014not even you can access the data.\\n\\n### \ud83c\udfe6 Financial Services\\nBuild KYC/AML compliant systems, secure payment authentication, or account recovery mechanisms that work across devices.\\n\\n## How It Works: The Technical Flow\\n\\n```\\n1. User takes selfie \u2192 2. Create ZelfProof \u2192 3. Store encrypted data\\n                           \u2193\\n4. User takes selfie \u2192 5. Decrypt ZelfProof \u2192 6. Access data/wallet/account\\n```\\n\\n**Key Point:** Your facial data never leaves your device. What gets sent to the server is a cryptographic proof that can\'t be reverse-engineered to recreate your face.\\n\\n## Quick Start: Create Your First ZelfProof\\n\\nLet\'s create a ZelfProof that encrypts a cryptocurrency wallet mnemonic. First, [sign up for a free account](https://app.verifik.co) to get your API key.\\n\\n### Step 1: Create a ZelfProof (Encryption)\\n\\n```bash\\ncurl -X POST \\"https://api.zelf.world/api/zelf-proof/encrypt\\" \\\\\\n  -H \\"Authorization: Bearer YOUR_API_KEY\\" \\\\\\n  -H \\"Content-Type: application/json\\" \\\\\\n  -d \'{\\n    \\"faceBase64\\": \\"BASE64_ENCODED_SELFIE\\",\\n    \\"metadata\\": {\\n      \\"mnemonic\\": \\"word1 word2 word3 ... word12\\",\\n      \\"walletAddress\\": \\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\\"\\n    },\\n    \\"publicData\\": {\\n      \\"userId\\": \\"user123\\",\\n      \\"createdAt\\": \\"2024-12-19\\"\\n    },\\n    \\"password\\": \\"optional-additional-security\\",\\n    \\"requireLiveness\\": true,\\n    \\"tolerance\\": \\"REGULAR\\"\\n  }\'\\n```\\n\\n**Response:**\\n```json\\n{\\n  \\"zelfProof\\": \\"A14THLzLTzI+57Nb52+PGXv...\\",\\n  \\"identifier\\": \\"user123\\"\\n}\\n```\\n\\n**What just happened?**\\n- The `metadata` object (with your wallet mnemonic) is encrypted using the facial biometric\\n- The `zelfProof` is a base64 string you can store in your database\\n- The `publicData` is readable without decryption (useful for displaying user info)\\n\\n### Step 2: Decrypt the ZelfProof (Authentication/Access)\\n\\n```bash\\ncurl -X POST \\"https://api.zelf.world/api/zelf-proof/decrypt\\" \\\\\\n  -H \\"Authorization: Bearer YOUR_API_KEY\\" \\\\\\n  -H \\"Content-Type: application/json\\" \\\\\\n  -d \'{\\n    \\"faceBase64\\": \\"BASE64_ENCODED_NEW_SELFIE\\",\\n    \\"zelfProof\\": \\"A14THLzLTzI+57Nb52+PGXv...\\",\\n    \\"password\\": \\"optional-additional-security\\",\\n    \\"requireLiveness\\": true,\\n    \\"tolerance\\": \\"REGULAR\\"\\n  }\'\\n```\\n\\n**Response:**\\n```json\\n{\\n  \\"identifier\\": \\"user123\\",\\n  \\"metadata\\": {\\n    \\"mnemonic\\": \\"word1 word2 word3 ... word12\\",\\n    \\"walletAddress\\": \\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\\"\\n  },\\n  \\"publicData\\": {\\n    \\"userId\\": \\"user123\\",\\n    \\"createdAt\\": \\"2024-12-19\\"\\n  },\\n  \\"faceCropBase64\\": \\"/9j/4AAQSkZJRg...\\",\\n  \\"difficulty\\": \\"EASY\\"\\n}\\n```\\n\\n**Success!** The user\'s face matched, and you\'ve decrypted the wallet mnemonic. Now you can sign transactions, unlock the account, or decrypt files.\\n\\n## Use Case #1: Building a Passwordless Login System\\n\\n```javascript\\n// Frontend: User registration\\nconst createUserAccount = async (selfieBase64, email) => {\\n  const response = await fetch(\'https://api.zelf.world/api/zelf-proof/encrypt\', {\\n    method: \'POST\',\\n    headers: {\\n      \'Authorization\': \'Bearer YOUR_API_KEY\',\\n      \'Content-Type\': \'application/json\'\\n    },\\n    body: JSON.stringify({\\n      faceBase64: selfieBase64,\\n      metadata: {\\n        email: email,\\n        userId: generateUUID(),\\n        createdAt: new Date().toISOString()\\n      },\\n      requireLiveness: true\\n    })\\n  });\\n  \\n  const { zelfProof, identifier } = await response.json();\\n  \\n  // Store zelfProof in your database linked to this user\\n  await saveToDatabase({ userId: identifier, zelfProof });\\n  \\n  return identifier;\\n};\\n\\n// Frontend: User login\\nconst loginUser = async (selfieBase64, userId) => {\\n  // Fetch the user\'s zelfProof from your database\\n  const { zelfProof } = await fetchFromDatabase(userId);\\n  \\n  const response = await fetch(\'https://api.zelf.world/api/zelf-proof/decrypt\', {\\n    method: \'POST\',\\n    headers: {\\n      \'Authorization\': \'Bearer YOUR_API_KEY\',\\n      \'Content-Type\': \'application/json\'\\n    },\\n    body: JSON.stringify({\\n      faceBase64: selfieBase64,\\n      zelfProof: zelfProof,\\n      requireLiveness: true\\n    })\\n  });\\n  \\n  if (response.ok) {\\n    const userData = await response.json();\\n    // User authenticated! Create session\\n    return createUserSession(userData.metadata);\\n  } else {\\n    throw new Error(\'Authentication failed\');\\n  }\\n};\\n```\\n\\n## Use Case #2: Cryptocurrency Hot Wallet\\n\\n```python\\nimport requests\\nimport json\\n\\ndef create_wallet(selfie_base64, mnemonic):\\n    \\"\\"\\"Create a ZelfProof-protected crypto wallet\\"\\"\\"\\n    \\n    response = requests.post(\\n        \'https://api.zelf.world/api/zelf-proof/encrypt\',\\n        headers={\\n            \'Authorization\': \'Bearer YOUR_API_KEY\',\\n            \'Content-Type\': \'application/json\'\\n        },\\n        json={\\n            \'faceBase64\': selfie_base64,\\n            \'metadata\': {\\n                \'mnemonic\': mnemonic,\\n                \'walletType\': \'ethereum\',\\n                \'chainId\': 1\\n            },\\n            \'publicData\': {\\n                \'address\': derive_address_from_mnemonic(mnemonic)\\n            },\\n            \'requireLiveness\': True,\\n            \'tolerance\': \'STRICT\'\\n        }\\n    )\\n    \\n    return response.json()[\'zelfProof\']\\n\\ndef sign_transaction(selfie_base64, zelf_proof, transaction_data):\\n    \\"\\"\\"Decrypt wallet and sign transaction\\"\\"\\"\\n    \\n    response = requests.post(\\n        \'https://api.zelf.world/api/zelf-proof/decrypt\',\\n        headers={\\n            \'Authorization\': \'Bearer YOUR_API_KEY\',\\n            \'Content-Type\': \'application/json\'\\n        },\\n        json={\\n            \'faceBase64\': selfie_base64,\\n            \'zelfProof\': zelf_proof,\\n            \'requireLiveness\': True\\n        }\\n    )\\n    \\n    if response.status_code == 200:\\n        data = response.json()\\n        mnemonic = data[\'metadata\'][\'mnemonic\']\\n        \\n        # Now use the mnemonic to sign the transaction\\n        signed_tx = sign_with_mnemonic(mnemonic, transaction_data)\\n        return signed_tx\\n    else:\\n        raise Exception(\'Face verification failed\')\\n```\\n\\n## Use Case #3: Encrypted Document Storage\\n\\n```typescript\\n// Encrypt a document with a user\'s face\\nasync function encryptDocument(\\n  userSelfie: string,\\n  documentContent: string\\n): Promise<string> {\\n  const response = await fetch(\'https://api.zelf.world/api/zelf-proof/encrypt\', {\\n    method: \'POST\',\\n    headers: {\\n      \'Authorization\': \'Bearer YOUR_API_KEY\',\\n      \'Content-Type\': \'application/json\'\\n    },\\n    body: JSON.stringify({\\n      faceBase64: userSelfie,\\n      metadata: {\\n        document: documentContent,\\n        encryptedAt: new Date().toISOString()\\n      },\\n      publicData: {\\n        documentName: \'Medical Record\',\\n        documentType: \'PDF\'\\n      },\\n      requireLiveness: true\\n    })\\n  });\\n  \\n  const { zelfProof } = await response.json();\\n  return zelfProof; // Store this in your database\\n}\\n\\n// Decrypt the document when user verifies their face\\nasync function decryptDocument(\\n  userSelfie: string,\\n  zelfProof: string\\n): Promise<string> {\\n  const response = await fetch(\'https://api.zelf.world/api/zelf-proof/decrypt\', {\\n    method: \'POST\',\\n    headers: {\\n      \'Authorization\': \'Bearer YOUR_API_KEY\',\\n      \'Content-Type\': \'application/json\'\\n    },\\n    body: JSON.stringify({\\n      faceBase64: userSelfie,\\n      zelfProof: zelfProof,\\n      requireLiveness: true\\n    })\\n  });\\n  \\n  const data = await response.json();\\n  return data.metadata.document; // Original document content\\n}\\n```\\n\\n## Understanding the API Response\\n\\nWhen you decrypt a ZelfProof, here\'s what you get back:\\n\\n```json\\n{\\n  \\"identifier\\": \\"user-unique-id\\",\\n  \\"metadata\\": {\\n    // Your encrypted data (only accessible with correct face)\\n    \\"secret\\": \\"sensitive-information\\",\\n    \\"walletKey\\": \\"private-key-data\\"\\n  },\\n  \\"publicData\\": {\\n    // Non-sensitive data (always readable)\\n    \\"name\\": \\"John Doe\\",\\n    \\"email\\": \\"john@example.com\\"\\n  },\\n  \\"faceCropBase64\\": \\"/9j/4AAQ...\\",  // Cropped face image\\n  \\"difficulty\\": \\"EASY\\"  // How difficult the face match was\\n}\\n```\\n\\n## Security Best Practices\\n\\n### \u2705 Do:\\n- Always enable `requireLiveness: true` in production\\n- Use `tolerance: \\"STRICT\\"` for high-security applications (wallets, payments)\\n- Add an optional `password` for additional security layer\\n- Store ZelfProofs in your database (they\'re safe to store\u2014they can\'t be reversed)\\n- Implement rate limiting on decrypt attempts\\n\\n### \u274c Don\'t:\\n- Never store the actual facial images on your servers\\n- Don\'t disable liveness detection in production\\n- Don\'t use `tolerance: \\"LOW\\"` for financial applications\\n- Don\'t share API keys in client-side code (use a backend proxy)\\n\\n## Try It Now: 5-Minute Integration\\n\\n1. **Sign up for free**: [app.verifik.co](https://app.verifik.co)\\n2. **Get your API key**: Available immediately in your dashboard\\n3. **Test in sandbox**: Use our test environment with no limits\\n4. **Read the docs**: [docs.verifik.co](https://docs.verifik.co) for complete API reference\\n5. **Join our Discord**: Get help from our developer community\\n\\n## API Reference Quick Links\\n\\n- **[Create ZelfProof (Encrypt)](https://docs.verifik.co/functions/create-qr-zelfproof)**: Encrypt data with facial biometrics\\n- **[Decrypt ZelfProof](https://docs.verifik.co/functions/decrypt-zelfproof)**: Verify face and decrypt data\\n- **[Preview ZelfProof](https://docs.verifik.co/api/tags/preview-zelfproof)**: View public data without decryption\\n- **[Full API Documentation](https://docs.verifik.co)**: Complete guides and examples\\n\\n## Real-World Success Stories\\n\\n- **Crypto Wallet App**: Reduced account recovery requests by 95%\\n- **Healthcare Platform**: HIPAA-compliant patient record access without storing biometric data\\n- **Enterprise SaaS**: Eliminated password resets, saving $50K/year in support costs\\n- **DeFi Protocol**: Enabled social recovery for MPC wallets using facial verification\\n\\n## Pricing\\n\\n- **Free Tier**: 1,000 API calls/month\\n- **Startup**: $99/month for 10,000 calls\\n- **Growth**: $299/month for 50,000 calls\\n- **Enterprise**: Custom pricing for unlimited calls\\n\\n**All tiers include:**\\n- Liveness detection\\n- Global CDN for fast response times\\n- 99.9% uptime SLA\\n- Technical support\\n\\n## Start Building Today\\n\\n```bash\\n# Get your API key\\ncurl -X POST https://app.verifik.co/api/auth/signup \\\\\\n  -d \\"email=you@example.com\\"\\n\\n# Make your first API call\\ncurl -X POST \\"https://api.zelf.world/api/zelf-proof/encrypt\\" \\\\\\n  -H \\"Authorization: Bearer YOUR_API_KEY\\" \\\\\\n  -H \\"Content-Type: application/json\\" \\\\\\n  -d \'{\\"faceBase64\\": \\"...\\", \\"metadata\\": {\\"test\\": \\"Hello World\\"}}\'\\n```\\n\\n## Get Help\\n\\n- \ud83d\udcda **Documentation**: [docs.verifik.co](https://docs.verifik.co)\\n- \ud83d\udcac **Discord Community**: [Join our developers](https://discord.gg/verifik)\\n- \ud83d\udc1b **GitHub**: [Report issues](https://github.com/verifik)\\n- \ud83d\udce7 **Email Support**: developers@verifik.co\\n\\n## What\'s Next?\\n\\n1. [Create your free account](https://app.verifik.co)\\n2. Get your API key\\n3. Try the examples above\\n4. Build something amazing!\\n\\n---\\n\\n**Ready to build the future of secure, passwordless authentication? Create your free account and start testing in minutes.**\\n\\n*No credit card required. 1,000 free API calls per month. Cancel anytime.*"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","source":"@site/blog/2021-08-26-welcome/index.md","title":"Welcome","description":"Docusaurus blogging features are powered by the blog plugin.","date":"2021-08-26T00:00:00.000Z","tags":[{"inline":false,"label":"Facebook","permalink":"/blog/tags/facebook","description":"Facebook tag description"},{"inline":false,"label":"Hello","permalink":"/blog/tags/hello","description":"Hello tag description"},{"inline":false,"label":"Docusaurus","permalink":"/blog/tags/docusaurus","description":"Docusaurus tag description"}],"readingTime":0.56,"hasTruncateMarker":true,"authors":[{"name":"S\xe9bastien Lorber","title":"Docusaurus maintainer","url":"https://sebastienlorber.com","page":{"permalink":"/blog/authors/all-sebastien-lorber-articles"},"socials":{"x":"https://x.com/sebastienlorber","linkedin":"https://www.linkedin.com/in/sebastienlorber/","github":"https://github.com/slorber","newsletter":"https://thisweekinreact.com"},"imageURL":"https://github.com/slorber.png","key":"slorber"},{"name":"Yangshun Tay","title":"Ex-Meta Staff Engineer, Co-founder GreatFrontEnd","url":"https://linkedin.com/in/yangshun","page":{"permalink":"/blog/authors/yangshun"},"socials":{"x":"https://x.com/yangshunz","linkedin":"https://www.linkedin.com/in/yangshun/","github":"https://github.com/yangshun","newsletter":"https://www.greatfrontend.com"},"imageURL":"https://github.com/yangshun.png","key":"yangshun"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["slorber","yangshun"],"tags":["facebook","hello","docusaurus"]},"unlisted":false,"prevItem":{"title":"Zero Knowledge Face Proofs: Build Secure Apps Without Storing Passwords or Biometric Data","permalink":"/blog/zero-knowledge-face-proofs-revolutionizing-digital-identity"}},"content":"[Docusaurus blogging features](https://docusaurus.io/docs/blog) are powered by the [blog plugin](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog).\\n\\nHere are a few tips you might find useful.\\n\\n\x3c!-- truncate --\x3e\\n\\nSimply add Markdown files (or folders) to the `blog` directory.\\n\\nRegular blog authors can be added to `authors.yml`.\\n\\nThe blog post date can be extracted from filenames, such as:\\n\\n- `2019-05-30-welcome.md`\\n- `2019-05-30-welcome/index.md`\\n\\nA blog post folder can be convenient to co-locate blog post images:\\n\\n![Docusaurus Plushie](./docusaurus-plushie-banner.jpeg)\\n\\nThe blog supports tags as well!\\n\\n**And if you don\'t want a blog**: just delete this directory, and use `blog: false` in your Docusaurus config."}]}}')}}]);